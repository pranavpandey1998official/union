// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'community_input.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$GetCommunityInput {
  int get communityID => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $GetCommunityInputCopyWith<GetCommunityInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetCommunityInputCopyWith<$Res> {
  factory $GetCommunityInputCopyWith(
          GetCommunityInput value, $Res Function(GetCommunityInput) then) =
      _$GetCommunityInputCopyWithImpl<$Res, GetCommunityInput>;
  @useResult
  $Res call({int communityID});
}

/// @nodoc
class _$GetCommunityInputCopyWithImpl<$Res, $Val extends GetCommunityInput>
    implements $GetCommunityInputCopyWith<$Res> {
  _$GetCommunityInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
  }) {
    return _then(_value.copyWith(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GetCommunityInputImplCopyWith<$Res>
    implements $GetCommunityInputCopyWith<$Res> {
  factory _$$GetCommunityInputImplCopyWith(_$GetCommunityInputImpl value,
          $Res Function(_$GetCommunityInputImpl) then) =
      __$$GetCommunityInputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int communityID});
}

/// @nodoc
class __$$GetCommunityInputImplCopyWithImpl<$Res>
    extends _$GetCommunityInputCopyWithImpl<$Res, _$GetCommunityInputImpl>
    implements _$$GetCommunityInputImplCopyWith<$Res> {
  __$$GetCommunityInputImplCopyWithImpl(_$GetCommunityInputImpl _value,
      $Res Function(_$GetCommunityInputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
  }) {
    return _then(_$GetCommunityInputImpl(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$GetCommunityInputImpl
    with DiagnosticableTreeMixin
    implements _GetCommunityInput {
  const _$GetCommunityInputImpl({required this.communityID});

  @override
  final int communityID;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GetCommunityInput(communityID: $communityID)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'GetCommunityInput'))
      ..add(DiagnosticsProperty('communityID', communityID));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetCommunityInputImpl &&
            (identical(other.communityID, communityID) ||
                other.communityID == communityID));
  }

  @override
  int get hashCode => Object.hash(runtimeType, communityID);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetCommunityInputImplCopyWith<_$GetCommunityInputImpl> get copyWith =>
      __$$GetCommunityInputImplCopyWithImpl<_$GetCommunityInputImpl>(
          this, _$identity);
}

abstract class _GetCommunityInput implements GetCommunityInput {
  const factory _GetCommunityInput({required final int communityID}) =
      _$GetCommunityInputImpl;

  @override
  int get communityID;
  @override
  @JsonKey(ignore: true)
  _$$GetCommunityInputImplCopyWith<_$GetCommunityInputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$JoinCommunityInput {
  int get communityID => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $JoinCommunityInputCopyWith<JoinCommunityInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $JoinCommunityInputCopyWith<$Res> {
  factory $JoinCommunityInputCopyWith(
          JoinCommunityInput value, $Res Function(JoinCommunityInput) then) =
      _$JoinCommunityInputCopyWithImpl<$Res, JoinCommunityInput>;
  @useResult
  $Res call({int communityID});
}

/// @nodoc
class _$JoinCommunityInputCopyWithImpl<$Res, $Val extends JoinCommunityInput>
    implements $JoinCommunityInputCopyWith<$Res> {
  _$JoinCommunityInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
  }) {
    return _then(_value.copyWith(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$JoinCommunityInputImplCopyWith<$Res>
    implements $JoinCommunityInputCopyWith<$Res> {
  factory _$$JoinCommunityInputImplCopyWith(_$JoinCommunityInputImpl value,
          $Res Function(_$JoinCommunityInputImpl) then) =
      __$$JoinCommunityInputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int communityID});
}

/// @nodoc
class __$$JoinCommunityInputImplCopyWithImpl<$Res>
    extends _$JoinCommunityInputCopyWithImpl<$Res, _$JoinCommunityInputImpl>
    implements _$$JoinCommunityInputImplCopyWith<$Res> {
  __$$JoinCommunityInputImplCopyWithImpl(_$JoinCommunityInputImpl _value,
      $Res Function(_$JoinCommunityInputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
  }) {
    return _then(_$JoinCommunityInputImpl(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$JoinCommunityInputImpl
    with DiagnosticableTreeMixin
    implements _JoinCommunityInput {
  const _$JoinCommunityInputImpl({required this.communityID});

  @override
  final int communityID;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'JoinCommunityInput(communityID: $communityID)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'JoinCommunityInput'))
      ..add(DiagnosticsProperty('communityID', communityID));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$JoinCommunityInputImpl &&
            (identical(other.communityID, communityID) ||
                other.communityID == communityID));
  }

  @override
  int get hashCode => Object.hash(runtimeType, communityID);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$JoinCommunityInputImplCopyWith<_$JoinCommunityInputImpl> get copyWith =>
      __$$JoinCommunityInputImplCopyWithImpl<_$JoinCommunityInputImpl>(
          this, _$identity);
}

abstract class _JoinCommunityInput implements JoinCommunityInput {
  const factory _JoinCommunityInput({required final int communityID}) =
      _$JoinCommunityInputImpl;

  @override
  int get communityID;
  @override
  @JsonKey(ignore: true)
  _$$JoinCommunityInputImplCopyWith<_$JoinCommunityInputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LeaveCommunityInput {
  int get communityID => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LeaveCommunityInputCopyWith<LeaveCommunityInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LeaveCommunityInputCopyWith<$Res> {
  factory $LeaveCommunityInputCopyWith(
          LeaveCommunityInput value, $Res Function(LeaveCommunityInput) then) =
      _$LeaveCommunityInputCopyWithImpl<$Res, LeaveCommunityInput>;
  @useResult
  $Res call({int communityID});
}

/// @nodoc
class _$LeaveCommunityInputCopyWithImpl<$Res, $Val extends LeaveCommunityInput>
    implements $LeaveCommunityInputCopyWith<$Res> {
  _$LeaveCommunityInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
  }) {
    return _then(_value.copyWith(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LeaveCommunityInputImplCopyWith<$Res>
    implements $LeaveCommunityInputCopyWith<$Res> {
  factory _$$LeaveCommunityInputImplCopyWith(_$LeaveCommunityInputImpl value,
          $Res Function(_$LeaveCommunityInputImpl) then) =
      __$$LeaveCommunityInputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int communityID});
}

/// @nodoc
class __$$LeaveCommunityInputImplCopyWithImpl<$Res>
    extends _$LeaveCommunityInputCopyWithImpl<$Res, _$LeaveCommunityInputImpl>
    implements _$$LeaveCommunityInputImplCopyWith<$Res> {
  __$$LeaveCommunityInputImplCopyWithImpl(_$LeaveCommunityInputImpl _value,
      $Res Function(_$LeaveCommunityInputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
  }) {
    return _then(_$LeaveCommunityInputImpl(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LeaveCommunityInputImpl
    with DiagnosticableTreeMixin
    implements _LeaveCommunityInput {
  const _$LeaveCommunityInputImpl({required this.communityID});

  @override
  final int communityID;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LeaveCommunityInput(communityID: $communityID)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LeaveCommunityInput'))
      ..add(DiagnosticsProperty('communityID', communityID));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LeaveCommunityInputImpl &&
            (identical(other.communityID, communityID) ||
                other.communityID == communityID));
  }

  @override
  int get hashCode => Object.hash(runtimeType, communityID);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LeaveCommunityInputImplCopyWith<_$LeaveCommunityInputImpl> get copyWith =>
      __$$LeaveCommunityInputImplCopyWithImpl<_$LeaveCommunityInputImpl>(
          this, _$identity);
}

abstract class _LeaveCommunityInput implements LeaveCommunityInput {
  const factory _LeaveCommunityInput({required final int communityID}) =
      _$LeaveCommunityInputImpl;

  @override
  int get communityID;
  @override
  @JsonKey(ignore: true)
  _$$LeaveCommunityInputImplCopyWith<_$LeaveCommunityInputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EvictUserFromCommunityInput {
  int get communityID => throw _privateConstructorUsedError;
  int get userIdToRemove => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EvictUserFromCommunityInputCopyWith<EvictUserFromCommunityInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EvictUserFromCommunityInputCopyWith<$Res> {
  factory $EvictUserFromCommunityInputCopyWith(
          EvictUserFromCommunityInput value,
          $Res Function(EvictUserFromCommunityInput) then) =
      _$EvictUserFromCommunityInputCopyWithImpl<$Res,
          EvictUserFromCommunityInput>;
  @useResult
  $Res call({int communityID, int userIdToRemove});
}

/// @nodoc
class _$EvictUserFromCommunityInputCopyWithImpl<$Res,
        $Val extends EvictUserFromCommunityInput>
    implements $EvictUserFromCommunityInputCopyWith<$Res> {
  _$EvictUserFromCommunityInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
    Object? userIdToRemove = null,
  }) {
    return _then(_value.copyWith(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
      userIdToRemove: null == userIdToRemove
          ? _value.userIdToRemove
          : userIdToRemove // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EvictUserFromCommunityInputImplCopyWith<$Res>
    implements $EvictUserFromCommunityInputCopyWith<$Res> {
  factory _$$EvictUserFromCommunityInputImplCopyWith(
          _$EvictUserFromCommunityInputImpl value,
          $Res Function(_$EvictUserFromCommunityInputImpl) then) =
      __$$EvictUserFromCommunityInputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int communityID, int userIdToRemove});
}

/// @nodoc
class __$$EvictUserFromCommunityInputImplCopyWithImpl<$Res>
    extends _$EvictUserFromCommunityInputCopyWithImpl<$Res,
        _$EvictUserFromCommunityInputImpl>
    implements _$$EvictUserFromCommunityInputImplCopyWith<$Res> {
  __$$EvictUserFromCommunityInputImplCopyWithImpl(
      _$EvictUserFromCommunityInputImpl _value,
      $Res Function(_$EvictUserFromCommunityInputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
    Object? userIdToRemove = null,
  }) {
    return _then(_$EvictUserFromCommunityInputImpl(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
      userIdToRemove: null == userIdToRemove
          ? _value.userIdToRemove
          : userIdToRemove // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$EvictUserFromCommunityInputImpl
    with DiagnosticableTreeMixin
    implements _EvictUserFromCommunityInput {
  const _$EvictUserFromCommunityInputImpl(
      {required this.communityID, required this.userIdToRemove});

  @override
  final int communityID;
  @override
  final int userIdToRemove;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'EvictUserFromCommunityInput(communityID: $communityID, userIdToRemove: $userIdToRemove)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'EvictUserFromCommunityInput'))
      ..add(DiagnosticsProperty('communityID', communityID))
      ..add(DiagnosticsProperty('userIdToRemove', userIdToRemove));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EvictUserFromCommunityInputImpl &&
            (identical(other.communityID, communityID) ||
                other.communityID == communityID) &&
            (identical(other.userIdToRemove, userIdToRemove) ||
                other.userIdToRemove == userIdToRemove));
  }

  @override
  int get hashCode => Object.hash(runtimeType, communityID, userIdToRemove);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EvictUserFromCommunityInputImplCopyWith<_$EvictUserFromCommunityInputImpl>
      get copyWith => __$$EvictUserFromCommunityInputImplCopyWithImpl<
          _$EvictUserFromCommunityInputImpl>(this, _$identity);
}

abstract class _EvictUserFromCommunityInput
    implements EvictUserFromCommunityInput {
  const factory _EvictUserFromCommunityInput(
      {required final int communityID,
      required final int userIdToRemove}) = _$EvictUserFromCommunityInputImpl;

  @override
  int get communityID;
  @override
  int get userIdToRemove;
  @override
  @JsonKey(ignore: true)
  _$$EvictUserFromCommunityInputImplCopyWith<_$EvictUserFromCommunityInputImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BlockUserFromCommunityInput {
  int get communityID => throw _privateConstructorUsedError;
  int get userIdToBlock => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BlockUserFromCommunityInputCopyWith<BlockUserFromCommunityInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlockUserFromCommunityInputCopyWith<$Res> {
  factory $BlockUserFromCommunityInputCopyWith(
          BlockUserFromCommunityInput value,
          $Res Function(BlockUserFromCommunityInput) then) =
      _$BlockUserFromCommunityInputCopyWithImpl<$Res,
          BlockUserFromCommunityInput>;
  @useResult
  $Res call({int communityID, int userIdToBlock});
}

/// @nodoc
class _$BlockUserFromCommunityInputCopyWithImpl<$Res,
        $Val extends BlockUserFromCommunityInput>
    implements $BlockUserFromCommunityInputCopyWith<$Res> {
  _$BlockUserFromCommunityInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
    Object? userIdToBlock = null,
  }) {
    return _then(_value.copyWith(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
      userIdToBlock: null == userIdToBlock
          ? _value.userIdToBlock
          : userIdToBlock // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BlockUserFromCommunityInputImplCopyWith<$Res>
    implements $BlockUserFromCommunityInputCopyWith<$Res> {
  factory _$$BlockUserFromCommunityInputImplCopyWith(
          _$BlockUserFromCommunityInputImpl value,
          $Res Function(_$BlockUserFromCommunityInputImpl) then) =
      __$$BlockUserFromCommunityInputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int communityID, int userIdToBlock});
}

/// @nodoc
class __$$BlockUserFromCommunityInputImplCopyWithImpl<$Res>
    extends _$BlockUserFromCommunityInputCopyWithImpl<$Res,
        _$BlockUserFromCommunityInputImpl>
    implements _$$BlockUserFromCommunityInputImplCopyWith<$Res> {
  __$$BlockUserFromCommunityInputImplCopyWithImpl(
      _$BlockUserFromCommunityInputImpl _value,
      $Res Function(_$BlockUserFromCommunityInputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
    Object? userIdToBlock = null,
  }) {
    return _then(_$BlockUserFromCommunityInputImpl(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
      userIdToBlock: null == userIdToBlock
          ? _value.userIdToBlock
          : userIdToBlock // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BlockUserFromCommunityInputImpl
    with DiagnosticableTreeMixin
    implements _BlockUserFromCommunityInput {
  const _$BlockUserFromCommunityInputImpl(
      {required this.communityID, required this.userIdToBlock});

  @override
  final int communityID;
  @override
  final int userIdToBlock;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BlockUserFromCommunityInput(communityID: $communityID, userIdToBlock: $userIdToBlock)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BlockUserFromCommunityInput'))
      ..add(DiagnosticsProperty('communityID', communityID))
      ..add(DiagnosticsProperty('userIdToBlock', userIdToBlock));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlockUserFromCommunityInputImpl &&
            (identical(other.communityID, communityID) ||
                other.communityID == communityID) &&
            (identical(other.userIdToBlock, userIdToBlock) ||
                other.userIdToBlock == userIdToBlock));
  }

  @override
  int get hashCode => Object.hash(runtimeType, communityID, userIdToBlock);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BlockUserFromCommunityInputImplCopyWith<_$BlockUserFromCommunityInputImpl>
      get copyWith => __$$BlockUserFromCommunityInputImplCopyWithImpl<
          _$BlockUserFromCommunityInputImpl>(this, _$identity);
}

abstract class _BlockUserFromCommunityInput
    implements BlockUserFromCommunityInput {
  const factory _BlockUserFromCommunityInput(
      {required final int communityID,
      required final int userIdToBlock}) = _$BlockUserFromCommunityInputImpl;

  @override
  int get communityID;
  @override
  int get userIdToBlock;
  @override
  @JsonKey(ignore: true)
  _$$BlockUserFromCommunityInputImplCopyWith<_$BlockUserFromCommunityInputImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UnblockUserFromCommunityInput {
  int get communityID => throw _privateConstructorUsedError;
  int get userIdToBlock => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UnblockUserFromCommunityInputCopyWith<UnblockUserFromCommunityInput>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnblockUserFromCommunityInputCopyWith<$Res> {
  factory $UnblockUserFromCommunityInputCopyWith(
          UnblockUserFromCommunityInput value,
          $Res Function(UnblockUserFromCommunityInput) then) =
      _$UnblockUserFromCommunityInputCopyWithImpl<$Res,
          UnblockUserFromCommunityInput>;
  @useResult
  $Res call({int communityID, int userIdToBlock});
}

/// @nodoc
class _$UnblockUserFromCommunityInputCopyWithImpl<$Res,
        $Val extends UnblockUserFromCommunityInput>
    implements $UnblockUserFromCommunityInputCopyWith<$Res> {
  _$UnblockUserFromCommunityInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
    Object? userIdToBlock = null,
  }) {
    return _then(_value.copyWith(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
      userIdToBlock: null == userIdToBlock
          ? _value.userIdToBlock
          : userIdToBlock // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UnblockUserFromCommunityInputImplCopyWith<$Res>
    implements $UnblockUserFromCommunityInputCopyWith<$Res> {
  factory _$$UnblockUserFromCommunityInputImplCopyWith(
          _$UnblockUserFromCommunityInputImpl value,
          $Res Function(_$UnblockUserFromCommunityInputImpl) then) =
      __$$UnblockUserFromCommunityInputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int communityID, int userIdToBlock});
}

/// @nodoc
class __$$UnblockUserFromCommunityInputImplCopyWithImpl<$Res>
    extends _$UnblockUserFromCommunityInputCopyWithImpl<$Res,
        _$UnblockUserFromCommunityInputImpl>
    implements _$$UnblockUserFromCommunityInputImplCopyWith<$Res> {
  __$$UnblockUserFromCommunityInputImplCopyWithImpl(
      _$UnblockUserFromCommunityInputImpl _value,
      $Res Function(_$UnblockUserFromCommunityInputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
    Object? userIdToBlock = null,
  }) {
    return _then(_$UnblockUserFromCommunityInputImpl(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
      userIdToBlock: null == userIdToBlock
          ? _value.userIdToBlock
          : userIdToBlock // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$UnblockUserFromCommunityInputImpl
    with DiagnosticableTreeMixin
    implements _UnblockUserFromCommunityInput {
  const _$UnblockUserFromCommunityInputImpl(
      {required this.communityID, required this.userIdToBlock});

  @override
  final int communityID;
  @override
  final int userIdToBlock;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'UnblockUserFromCommunityInput(communityID: $communityID, userIdToBlock: $userIdToBlock)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'UnblockUserFromCommunityInput'))
      ..add(DiagnosticsProperty('communityID', communityID))
      ..add(DiagnosticsProperty('userIdToBlock', userIdToBlock));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnblockUserFromCommunityInputImpl &&
            (identical(other.communityID, communityID) ||
                other.communityID == communityID) &&
            (identical(other.userIdToBlock, userIdToBlock) ||
                other.userIdToBlock == userIdToBlock));
  }

  @override
  int get hashCode => Object.hash(runtimeType, communityID, userIdToBlock);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnblockUserFromCommunityInputImplCopyWith<
          _$UnblockUserFromCommunityInputImpl>
      get copyWith => __$$UnblockUserFromCommunityInputImplCopyWithImpl<
          _$UnblockUserFromCommunityInputImpl>(this, _$identity);
}

abstract class _UnblockUserFromCommunityInput
    implements UnblockUserFromCommunityInput {
  const factory _UnblockUserFromCommunityInput(
      {required final int communityID,
      required final int userIdToBlock}) = _$UnblockUserFromCommunityInputImpl;

  @override
  int get communityID;
  @override
  int get userIdToBlock;
  @override
  @JsonKey(ignore: true)
  _$$UnblockUserFromCommunityInputImplCopyWith<
          _$UnblockUserFromCommunityInputImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GetCommunityFeedInput {
  int get communityID => throw _privateConstructorUsedError;
  OrderBy get orderBy => throw _privateConstructorUsedError;
  SortBy get sortOrder => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $GetCommunityFeedInputCopyWith<GetCommunityFeedInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetCommunityFeedInputCopyWith<$Res> {
  factory $GetCommunityFeedInputCopyWith(GetCommunityFeedInput value,
          $Res Function(GetCommunityFeedInput) then) =
      _$GetCommunityFeedInputCopyWithImpl<$Res, GetCommunityFeedInput>;
  @useResult
  $Res call({int communityID, OrderBy orderBy, SortBy sortOrder});
}

/// @nodoc
class _$GetCommunityFeedInputCopyWithImpl<$Res,
        $Val extends GetCommunityFeedInput>
    implements $GetCommunityFeedInputCopyWith<$Res> {
  _$GetCommunityFeedInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
    Object? orderBy = null,
    Object? sortOrder = null,
  }) {
    return _then(_value.copyWith(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
      orderBy: null == orderBy
          ? _value.orderBy
          : orderBy // ignore: cast_nullable_to_non_nullable
              as OrderBy,
      sortOrder: null == sortOrder
          ? _value.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as SortBy,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GetCommunityFeedInputImplCopyWith<$Res>
    implements $GetCommunityFeedInputCopyWith<$Res> {
  factory _$$GetCommunityFeedInputImplCopyWith(
          _$GetCommunityFeedInputImpl value,
          $Res Function(_$GetCommunityFeedInputImpl) then) =
      __$$GetCommunityFeedInputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int communityID, OrderBy orderBy, SortBy sortOrder});
}

/// @nodoc
class __$$GetCommunityFeedInputImplCopyWithImpl<$Res>
    extends _$GetCommunityFeedInputCopyWithImpl<$Res,
        _$GetCommunityFeedInputImpl>
    implements _$$GetCommunityFeedInputImplCopyWith<$Res> {
  __$$GetCommunityFeedInputImplCopyWithImpl(_$GetCommunityFeedInputImpl _value,
      $Res Function(_$GetCommunityFeedInputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? communityID = null,
    Object? orderBy = null,
    Object? sortOrder = null,
  }) {
    return _then(_$GetCommunityFeedInputImpl(
      communityID: null == communityID
          ? _value.communityID
          : communityID // ignore: cast_nullable_to_non_nullable
              as int,
      orderBy: null == orderBy
          ? _value.orderBy
          : orderBy // ignore: cast_nullable_to_non_nullable
              as OrderBy,
      sortOrder: null == sortOrder
          ? _value.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as SortBy,
    ));
  }
}

/// @nodoc

class _$GetCommunityFeedInputImpl
    with DiagnosticableTreeMixin
    implements _GetCommunityFeedInput {
  const _$GetCommunityFeedInputImpl(
      {required this.communityID,
      required this.orderBy,
      required this.sortOrder});

  @override
  final int communityID;
  @override
  final OrderBy orderBy;
  @override
  final SortBy sortOrder;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GetCommunityFeedInput(communityID: $communityID, orderBy: $orderBy, sortOrder: $sortOrder)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'GetCommunityFeedInput'))
      ..add(DiagnosticsProperty('communityID', communityID))
      ..add(DiagnosticsProperty('orderBy', orderBy))
      ..add(DiagnosticsProperty('sortOrder', sortOrder));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetCommunityFeedInputImpl &&
            (identical(other.communityID, communityID) ||
                other.communityID == communityID) &&
            (identical(other.orderBy, orderBy) || other.orderBy == orderBy) &&
            (identical(other.sortOrder, sortOrder) ||
                other.sortOrder == sortOrder));
  }

  @override
  int get hashCode => Object.hash(runtimeType, communityID, orderBy, sortOrder);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetCommunityFeedInputImplCopyWith<_$GetCommunityFeedInputImpl>
      get copyWith => __$$GetCommunityFeedInputImplCopyWithImpl<
          _$GetCommunityFeedInputImpl>(this, _$identity);
}

abstract class _GetCommunityFeedInput implements GetCommunityFeedInput {
  const factory _GetCommunityFeedInput(
      {required final int communityID,
      required final OrderBy orderBy,
      required final SortBy sortOrder}) = _$GetCommunityFeedInputImpl;

  @override
  int get communityID;
  @override
  OrderBy get orderBy;
  @override
  SortBy get sortOrder;
  @override
  @JsonKey(ignore: true)
  _$$GetCommunityFeedInputImplCopyWith<_$GetCommunityFeedInputImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CreateCommunityInput {
  String get name => throw _privateConstructorUsedError;
  String get about => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CreateCommunityInputCopyWith<CreateCommunityInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateCommunityInputCopyWith<$Res> {
  factory $CreateCommunityInputCopyWith(CreateCommunityInput value,
          $Res Function(CreateCommunityInput) then) =
      _$CreateCommunityInputCopyWithImpl<$Res, CreateCommunityInput>;
  @useResult
  $Res call({String name, String about});
}

/// @nodoc
class _$CreateCommunityInputCopyWithImpl<$Res,
        $Val extends CreateCommunityInput>
    implements $CreateCommunityInputCopyWith<$Res> {
  _$CreateCommunityInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? about = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      about: null == about
          ? _value.about
          : about // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CreateCommunityInputImplCopyWith<$Res>
    implements $CreateCommunityInputCopyWith<$Res> {
  factory _$$CreateCommunityInputImplCopyWith(_$CreateCommunityInputImpl value,
          $Res Function(_$CreateCommunityInputImpl) then) =
      __$$CreateCommunityInputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String about});
}

/// @nodoc
class __$$CreateCommunityInputImplCopyWithImpl<$Res>
    extends _$CreateCommunityInputCopyWithImpl<$Res, _$CreateCommunityInputImpl>
    implements _$$CreateCommunityInputImplCopyWith<$Res> {
  __$$CreateCommunityInputImplCopyWithImpl(_$CreateCommunityInputImpl _value,
      $Res Function(_$CreateCommunityInputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? about = null,
  }) {
    return _then(_$CreateCommunityInputImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      about: null == about
          ? _value.about
          : about // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateCommunityInputImpl
    with DiagnosticableTreeMixin
    implements _CreateCommunityInput {
  const _$CreateCommunityInputImpl({required this.name, required this.about});

  @override
  final String name;
  @override
  final String about;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CreateCommunityInput(name: $name, about: $about)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CreateCommunityInput'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('about', about));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateCommunityInputImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.about, about) || other.about == about));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name, about);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CreateCommunityInputImplCopyWith<_$CreateCommunityInputImpl>
      get copyWith =>
          __$$CreateCommunityInputImplCopyWithImpl<_$CreateCommunityInputImpl>(
              this, _$identity);
}

abstract class _CreateCommunityInput implements CreateCommunityInput {
  const factory _CreateCommunityInput(
      {required final String name,
      required final String about}) = _$CreateCommunityInputImpl;

  @override
  String get name;
  @override
  String get about;
  @override
  @JsonKey(ignore: true)
  _$$CreateCommunityInputImplCopyWith<_$CreateCommunityInputImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SearchCommunityInput {
  String get query => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SearchCommunityInputCopyWith<SearchCommunityInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchCommunityInputCopyWith<$Res> {
  factory $SearchCommunityInputCopyWith(SearchCommunityInput value,
          $Res Function(SearchCommunityInput) then) =
      _$SearchCommunityInputCopyWithImpl<$Res, SearchCommunityInput>;
  @useResult
  $Res call({String query});
}

/// @nodoc
class _$SearchCommunityInputCopyWithImpl<$Res,
        $Val extends SearchCommunityInput>
    implements $SearchCommunityInputCopyWith<$Res> {
  _$SearchCommunityInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? query = null,
  }) {
    return _then(_value.copyWith(
      query: null == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SearchCommunityInputImplCopyWith<$Res>
    implements $SearchCommunityInputCopyWith<$Res> {
  factory _$$SearchCommunityInputImplCopyWith(_$SearchCommunityInputImpl value,
          $Res Function(_$SearchCommunityInputImpl) then) =
      __$$SearchCommunityInputImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String query});
}

/// @nodoc
class __$$SearchCommunityInputImplCopyWithImpl<$Res>
    extends _$SearchCommunityInputCopyWithImpl<$Res, _$SearchCommunityInputImpl>
    implements _$$SearchCommunityInputImplCopyWith<$Res> {
  __$$SearchCommunityInputImplCopyWithImpl(_$SearchCommunityInputImpl _value,
      $Res Function(_$SearchCommunityInputImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? query = null,
  }) {
    return _then(_$SearchCommunityInputImpl(
      query: null == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SearchCommunityInputImpl
    with DiagnosticableTreeMixin
    implements _SearchCommunityInput {
  const _$SearchCommunityInputImpl({required this.query});

  @override
  final String query;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SearchCommunityInput(query: $query)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SearchCommunityInput'))
      ..add(DiagnosticsProperty('query', query));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchCommunityInputImpl &&
            (identical(other.query, query) || other.query == query));
  }

  @override
  int get hashCode => Object.hash(runtimeType, query);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchCommunityInputImplCopyWith<_$SearchCommunityInputImpl>
      get copyWith =>
          __$$SearchCommunityInputImplCopyWithImpl<_$SearchCommunityInputImpl>(
              this, _$identity);
}

abstract class _SearchCommunityInput implements SearchCommunityInput {
  const factory _SearchCommunityInput({required final String query}) =
      _$SearchCommunityInputImpl;

  @override
  String get query;
  @override
  @JsonKey(ignore: true)
  _$$SearchCommunityInputImplCopyWith<_$SearchCommunityInputImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GetTrendingCommunitiesInput {}

/// @nodoc
abstract class $GetTrendingCommunitiesInputCopyWith<$Res> {
  factory $GetTrendingCommunitiesInputCopyWith(
          GetTrendingCommunitiesInput value,
          $Res Function(GetTrendingCommunitiesInput) then) =
      _$GetTrendingCommunitiesInputCopyWithImpl<$Res,
          GetTrendingCommunitiesInput>;
}

/// @nodoc
class _$GetTrendingCommunitiesInputCopyWithImpl<$Res,
        $Val extends GetTrendingCommunitiesInput>
    implements $GetTrendingCommunitiesInputCopyWith<$Res> {
  _$GetTrendingCommunitiesInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GetTrendingCommunitiesInputImplCopyWith<$Res> {
  factory _$$GetTrendingCommunitiesInputImplCopyWith(
          _$GetTrendingCommunitiesInputImpl value,
          $Res Function(_$GetTrendingCommunitiesInputImpl) then) =
      __$$GetTrendingCommunitiesInputImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetTrendingCommunitiesInputImplCopyWithImpl<$Res>
    extends _$GetTrendingCommunitiesInputCopyWithImpl<$Res,
        _$GetTrendingCommunitiesInputImpl>
    implements _$$GetTrendingCommunitiesInputImplCopyWith<$Res> {
  __$$GetTrendingCommunitiesInputImplCopyWithImpl(
      _$GetTrendingCommunitiesInputImpl _value,
      $Res Function(_$GetTrendingCommunitiesInputImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetTrendingCommunitiesInputImpl
    with DiagnosticableTreeMixin
    implements _GetTrendingCommunitiesInput {
  const _$GetTrendingCommunitiesInputImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'GetTrendingCommunitiesInput()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'GetTrendingCommunitiesInput'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetTrendingCommunitiesInputImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _GetTrendingCommunitiesInput
    implements GetTrendingCommunitiesInput {
  const factory _GetTrendingCommunitiesInput() =
      _$GetTrendingCommunitiesInputImpl;
}
